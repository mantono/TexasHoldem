\avsnitt{Testdriven utveckling -- process}

En översikt över hur ni tillämpat TDD med exempel från olika personer och olika faser i projektet. 
Om ni har använt versionshanteringssystemet ordentligt bör all information som efterfrågas här finnas i det. Tänk på att kodexemplen ska vara läsbara.

Alla fyra har tillämpat testdriven utveckling under större delar av projektets gång. 
Till en början var vi hårda på att använda testdriven utveckling men desto längre in i projektet vi kom så släppte vi på det för att få in alla funktioner i programmet.
Även om vi inte var lika hårda i slutet på att tillämpa tdd så övergav vi ändå inte det helt då vi kände att det var ett väldigt använbart verktyg. Den enda skillnaden
mot i början av projektet var att det ibland hände att vi inte skrev testfallen före koden som vi var väldigt hårda med i början av projektet när vi hade som regel att implementera 
tdd till 100%. 
Nedan kommer 4 olika exempel på testfall som skrivits av alla personer i projektet och den kom som togs fram med hjälp av testfallen:

Elliot

\begin(lstlisting)
	@Test
	public void betSizeTestFromEmptyPot(){		
		Pot emptyPot = new Pot();
		emptyPot.receiveBet(300,player1);
		assertEquals(300, emptyPot.getAmount());		
	}
	
	@Test
	public void betSizeTestFromPositiveSize() {
		Pot positivePot = new Pot(1);
		positivePot.receiveBet(300,player1);
		assertEquals(301, positivePot.getAmount());
	}
\end(lstlisting)
\begin(lstlisting)
public void receiveBet(int bet, Player player) {
		if (bet < 1)
			throw new IllegalArgumentException(
					"The Bet has to be larger than 0");
		else {
			amount += bet;
			betHistory.put(player, this.getBetHistory(player) + bet);

		}
	}
\end(lstlisting)

Rasmus

\begin(lstlisting)
@Test(expected = IllegalArgumentException.class)
	public void testForInvalidSize() {
		Pot invalidPot = new Pot(-1);
		assertEquals(-1, invalidPot.getAmount());
	}
\end(lstlisting)
@Test
	public void testPotSizeIfPositiveInt() {
		Pot pot = new Pot(500);
		assertEquals(500, pot.getAmount());

	
\begin(lstlisting
	Pot pot = new Pot(500);
	assertEquals(500, pot.getAmount());
\end(lstlisting)
\begin(lstlisting
public Pot(int amount) {
		if (amount < 0)
			throw new IllegalArgumentException(
					"The Pot has to be at least 0");

		this.amount = amount;
	}
\end(lstlisting)

Emil
\begin(lstlisting
@Test
	public void addingOnePlayerTest(){
		Game newGame = new Game(4, 0.3, kalle);
		assertTrue(newGame.getPlayers().contains(kalle));
	}
@Test

	public void addingPlayersTest(){
		Game newGame = new Game(4, 0.3, kalle, pelle);
		assertTrue(newGame.getPlayers().contains(kalle));
		assertTrue(newGame.getPlayers().contains(pelle));
	}
public Game(int bigBlind, double blindsRaisePercentage, Player... players) {
		this(players);
		if (bigBlind < 1)
			throw new IllegalArgumentException(
					"Error: parameter bigBlind is less than 1.");
		if (blindsRaisePercentage < 0)
			throw new IllegalArgumentException(
					"Error: parameter blindsRaisePercentage is less than 0.");
		this.bigBlind = bigBlind;
		this.blindsRaisePercentage = blindsRaisePercentage;
	}
\end(lstlisting)
Anton

-----------------



\avsnitt{Testdriven utveckling -- erfarenheter}

En diskussion om vilka era erfarenheter ni dragit av att tillämpa TDD. Det finns inget rätt eller fel här. 
Enda sättet att bli underkända är att bara fuska över punkten och säga något pliktskyldigt.

----------------

Vi har arbetat med testdriven utveckling nästan helt och hållet genom projektet vilket har gett oss en mängd erfarenheter av hur bra/dåligt det kan fungera. 
Till en början kändes det väldigt överflödigt och framtvingat då man arbetade med simpla metoder, 
klasser och konstruktioner som kändes självklara hur man skulle skriva och som alltid fungerade direkt. 
Desto mer vi arbetade och kom in i svårare metoder och konstruktioner så började testdriven utveckling kännas mer och mer användbart och mot slutet i projektet, 
speciellt när vi arbetade med klasses TexasRules, så kändes det nästan som att det hade varit omöjligt att genomföra den delen utan testdriven utveckling och testfall. 
Eftersom man i klassen TexasRules behövde testa väldigt specifika fall, som t ex att rätt person vinner om båda har stege men en av personerna har högre kort, 
så gjorde testfall att man enkelt kunde sätta upp ett eller flera komplexa fall som endast gått igenom om koden är korrekt skriven. 
Detta skulle vara väldigt svårt att testa utan testfall.

Testdriven utveckling ledde också till att vi snabbt upptäckte fel som introducerats i koden. 
Detta eftersom man kunde se om ett testfall gått igenom tidigare antingen i commit-kommentarerna eller för att man själv kört dem tidigare och 
då också se om man kan ha introducerat något fel i en specifik del av koden. Lyckades man då inte se vilket fel man introducerat 
så gick det alltid att titta på versionen som commitats t ex med kommentaren \emph{testfall X går nu igenom} och se hur koden såg ut i det tillfället.

En ytterliggare positiv effekt av testdriven utveckling som vi inte tänkt på i förhand är att den gör koden mycket mer lättförståelig 
för de man arbetar med då man kan se hur koden är tänkt att fungera även om den inte i nuvarande läge fungerar. Detta leder till att man enkelt kan ta över metoder 
och skriva klart dem även om det inte var man själv som började skriva på den. Även om man har dokumentation om ungefär vad metoden ska göra, 
så ger testfallen mycket med information om exakt hur metoden ska bete sig och vilket resultat som förväntas.

Vi har förstås också fått uppleva några utav baksidorna med testdriven utveckling. Det är tidskrävande, 
speciellt att skriva bra tester som ger god täckningsgrad och täcker alla ekvivalensklasser. 
Det krävs god disciplin för att inte slarva och börja övergå i ad-hoc-testning, speciellt under tidspress, 
något som vi kanske inte kan säga att vi alltid lyckats med. Det är inte heller alla gånger som vi varit helt överens om hur vi ska prioritera testbarhet kontra inkapsling. 
Oftast har vi lyckats finna någon kompromiss där t.ex. privata metoder har varit testbara via publika metoder där den privata anropas.
