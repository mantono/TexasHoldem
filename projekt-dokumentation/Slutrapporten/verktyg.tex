\avsnitt{Kodkritiksystem}

Vi körde FindBugs vid ett flertal tillfällen under utvecklingen med olika resultat men den slutsatsen vi ändå kunde dra av detta var att FindBugs var en av de minst användbara verktygen vi testat oss på,
när den användes för första gången precis innan den första granskningen så hittade den inte ett enda fel, även när känsligheten drogs upp på max och vi bad den rapportera allt den möjligen kunde hitta.
Det fanns dock inga större fel vid denna punkt men vi hittade ändå rätt mycket saker som vi behövde ändra när vi körde vår formella granskning som FindBugs ej hade hittat. Många av de felen vi hittade
hade dock med namngivning och liknande att göra vilket är svårare för ett program att hitta. Vi körde också FindBugs efter vi gjort korrigeringar efter granskningen men hittade då heller inga fel.
Vi körde däremot FindBugs mot slutet av projektet också och då hittade den dessa ``fel'':

\begin{enumerate}
\item TexasRules.java:32 texasholdem.TexasRules.equals(Object) always returns false [Scary(7), High confidence]
\item TexasRules.java:128 Potentially dangerous use of non-short-circuit logic in texasholdem.TexasRules.hasFullHouse(Hand) [Of Concern(15), High confidence]
\item Hand.java:10 Class cards.Hand implements Cloneable but does not define or use clone method [Of Concern(16), Normal confidence]
\item TexasRules.java:12 texasholdem.TexasRules implements Comparator but not Serializable [Of Concern(19), Normal confidence]
\item Game.java:175 Dead store to amountOfErrors in texasholdem.Game.distributeChip(ArrayList) [Of Concern(20), Low confidence]
\item Hand.java:36 Confusing to have methods cards.Hand.addToHand(Card[]) and cards.Player.addTohand(Card[]) [Of Concern(19), Low confidence]
\end{enumerate}

Ett utav felen som hittades (1) i TexasRules var helt enkelt en följd utav att klassen inte var färdig, medan de andra två i klassen (2, 4) var av kanske större intresse trots att klassen fortfarande kommer göras om i stor utsträckning. Tredje punkten om \emph{Cloneable} var intressant då vi faktsitk trodde att vi hade implementerat det gränssnittet i klassen, så det var verkligen något vi hade missat. De sista två punkterna (5, 6) är ju strängt taget inga ``fel'' men är förstås av intresse ändå och båda kommer nog kräva någon form av åtgärd från vår sida. Det ska dock erkännas att vi redan var medvetna om \emph{amountOfErrors} (5) inte används just nu. Det råder nog dock lite förvirring om varför den existerar och om den kommer fylla någon funktion i framtiden, varför det kan vara bra att påminnas om att den i nuläget inte fyller någon funktion.

\avsnitt{Statiska mått}

En presentation och diskussion kring ett antal lämpliga statiska mått på koden. Att vi inte specificerar exakt vilka mått som ska tas upp beror på att olika verktyg har olika uppsättningar, men vi förväntar oss fler och mer intressanta mått än bara rena storleksmått som LOC, \#klasser, \#metoder, etc. Även här är det viktigt att förhållas sig till måtten, inte bara lista dem.\\

\textbf{Number of Classes}: 8 (exklusive testfall, interface och enums)
\begin{enumerate}
	\item cards: 5
	\item texasholdem: 3
\end{enumerate}

\textbf{Total Lines of Code}: 2014
\begin{enumerate}
	\item testfall: 1140 (56,6\%)
	\item texasholdem: 476  (23,6\%)
	\item cards: 398 (19,7\%)
\end{enumerate}

Det som kan vara intressant med resultaten för \emph{Number of Classes} och \emph{Total Lines of Code} är det faktum att paketet texasholdem har färre klasser än cards, men fler antal rader kod. Man bör kanske fundera på varför det har blivit så, och fråga sig om det verkligen är bra. Detta är något som i sin tur står i korrelation till de metrics som följer.\\

\textbf{Lack of Cohesion (mean)}:  0,403
\begin{enumerate}
	\item Game: 0,806
	\item Player: 0,795
	\item CardGame: 0,717
\end{enumerate}

Kanske inte helt oväntat så är den största klassen, Game, den som har högst avsaknad av coheshion. Intresasnt är att i ett tidigare skede så var Game och CardGame en och samma klass, och trots denna uppdelning så har båda dessa vuxit på ett sätt som kanske inte är önksvärt. Både Game och CardGame börjar få lite \emph{God-klass}-tendenser och bör ses över.  Vi har sagt att om vi väljer att fortsätta att utveckla vårt bibliotek så kommer en ytterliggare uppdelning av någon (eller alla) av de tre klasserna vara aktuellt. Player sticker ut lite som är en ganska liten klass jämfört med de andra två (ca 60 LoC jämfört med 230 respektive 110) men trots det så har den rätt stor avsaknad av cohesion. De flesta av klassens metoder arbetar antingen på variablen \emph{chips} eller objektet \emph{hand}, men ingen av klassens metoder arbetar på båda dessa. Resultat är med andra ord inte så förvånande.

Eftersom att hantering av chips inte är en funktion som är generell för alla kortspel, så bör vi kanske överväga att avlägsna chips-hanteringen från den generella klassen Player och lägga in i en separat klass, möjligen en subklass.\\

\textbf{MacCabe Cyclomatic Complexity (mean)}: 1,632
\begin{enumerate}
	\item Pot:handOutChips() - 9
	\item TexasRules:hasCombination() - 9
	\item Game:placeBlinds() - 7
	\item Game:playerAction() - 7
\end{enumerate}

Den relativt sett höga komplexiteten på några av de metoder som finns ger kanske en fingervisning om att det finns utrymme för förbättring. Metoderna handOutChips och placeBlinds skulle förmodligen kunna refaktoriseras och delas upp i flera mindre metoder för att minska komplexiteten något, även om komplexiteten i sig gör det svårare. Metoderna hasCombination och playerAction har lika hög komplexitet som de nyss nämnda, men detta främst till följd av att de har switch-satser, varför de kan vara en än större utmaning att dela upp dem i flera mindre metoder.\\


\textbf{Number of Parameters (mean)}: 0,667
\begin{enumerate}
	\item Pot:handOutChips(Player player, int chipsWon, int playersWon) - 3
	\item Game:Game(int bigBlind, double blindsRaisePercentage, Player... players) - 3
\end{enumerate}

Vi har överlag lyckats hålla nere antalet parametrar för metoderna i vårt bibliotek. Kontruktorn ovan behöver dessutom bara två av de tre argumenten då den sista är en varargs som inte är obligatorisk.\\

\textbf{Method Lines of Code (mean)}: 4.313
\begin{enumerate}
	\item Pot:handOutChips() - 34
	\item Game:distributeChip() - 22
	\item Game:placeBlinds() - 14
\end{enumerate}

Som man kanske hade kunnat gissa så kan man se ett samband mellan \emph{MacCabe Cyclomatic Complexity} och \emph{Method Lines of Code} där en mer komplex metod kan utgöra ett motstånd för att bryta upp den i flera mindre metoder.

Dessa statiska mått är var och för sig, av ganska begränsad nytta, men tillsammans ger de en ganska god bild av vilka förbättringar som köras på projektet som helhet och enskilda klasser och metoder.\\


\textbf{Pizza metric index}: 1\\
Vi har inte råd att äta mer pizza.

\avsnitt{Täckningsgrad}
Vi har närmast 100\% täckningsgrad. Det finns två klasser som inte riktigt når hela vägen. I det ena fallet handlar det om klassen Deck som har en metod setSeed som matar ett SecureRandom-objekt med ny data för seeden. Metoden är protected och anropas aldrig i dagsläget av någon annan metod i paketet då vi är osäkra på om vi faktiskt behöver den eller inte. Det kan faktiskt vara så att vi kommer ta bort metoden, men fram till dess att vi är helt säkra på att det är rätt beslut får den ligga kvar.

Den andra klassen som inte har 100\% täckningsgrad är TexasRules. Det är helt enkelt för att vi har kommit fram till att stora delar av koden måste skrivas om, och vi ser ingen poäng med att försöka få full täckning för kod som vi kommer ta bort.

\DeclareGraphicsExtensions{.png}
\includegraphics[natwidth=350, natheight=258, scale=0.9, angle=0, trim = 0mm 0mm 0mm 0mm, clip]{bilder/coverage}\\


\avsnitt{Profiler}

Vi skrev ett profilertest där ett antal huvudmetoder loopas igenom ett flertal gånger så att processen håller på ett tag så att vi kunde se hur mycket våra metoder påverkar datorns prestanda. Vi försökte använda NetBeans först, men då det inte funkade blev vi tvugna att använda Eclipse egna profiler (JVM monitor).

\DeclareGraphicsExtensions{.png}
\includegraphics[natwidth=809, natheight=349, scale=0.69, angle=0, trim = 14mm 0mm 0mm 0mm]{bilder/profiler/crop}\\

Det första vi märkte av resultatet var att metoden drawCards() (poängtera pluralet dvs inte drawCard()) drog absolut mest CPU jämfört med alla andra metoder. Vi diskuterade om varför det kan ha blivit så, och vi kom fram till två teorier. Den första är att drawCards() använder sig utav \emph{SecureRandom.nextInt()}, vilket vi har förstått är en väldigt komplicerad klass, och därför drar mycket CPU-kraft. Den metod som drar näst mest kraft är drawCard(), som också använder sig utav \emph{SecureRandom.nextInt()}, vilket stödjer denna teori. Den andra teorin vi hade var att drawCards() anroppades absolut mest gånger utav alla andra metoder, vilket i sin tur resulterar i en mycket större sammanlagd CPU-kraft, vilket är vad profilen visar.

Men vi vågar inte riktigt dra några säkra slutsatser av den data som profilern gav oss. Kanske om profilern tillät oss att köra endast ett game (vi försökte, men programmet avslutades så snabbt att vi inte kunde se CPU-datan) istället för flera tusen så skulle vi kunna komma närmare vilken teori som stämmer, eller alternativt om profilern lät oss gå djupare till exakt vilka sub-metoder av varje anropp som tar mest kraft skulle det också ge någon klarhet. Men denna information gav inte profilern, och detta tillåter oss endast att spekulera.

All in all tycker vi att profilern var en av de minst användbara testningsmetoden vi använde oss utav, då det är mycket tydligt att det är menade för större projekt, och gav inte tillräckligt med detaljrik information för att vara till värde för oss. För ett klassbibliotek av den här storleken finns det helt klart andra saker som man kan fokusera mer på istället.

\avsnitt{Byggscript}

Byggscriptets första (seriösa) version, och den slutliga.

I den första versionen av byggscriptet var ambitionen främst att det skulle göra ungefär samma sak som den standard-byggscripten som Eclipse skapar för ett projekt. Med andra ord, kompilera alla klasser och dess beroenden. Det gick ganska bra fram till dess att testfallen inkluderades, då det krävdes externa bibliotek (JUnit) för att kompilera dessa. Så småningom fick vi även det att fungera.

 \lstset{
	language=XML,
	basicstyle=\ttfamily\scriptsize,
	keywordstyle=\color{blue}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	showspaces=false,
	breaklines=true
 }

\begin{lstlisting}[float,caption={build.xml, första versionen},label=lst]
<?xml version="1.0"?>
<project name="texas" default="buildTest" basedir=".">
<property name="build.dir" location="bin" />
<property name="srcCards.dir" value="src/cards" />
<property name="srcTexasHoldem.dir" value="src/texasholdem" />
<property name="srcTest.dir" value="test" />

<property name="test.report.dir" location="testreports" />

<path id="junit.class.path">
	<pathelement location="${eclipse}/plugins/org.junit*/*junit.jar" />
	<pathelement location="/home/anton/dokument/eclipse/plugins/org.junit_4.11.0.v201303080030/junit.jar" />
	<pathelement location="${eclipse}/plugins/*org.hamcrest.*.jar" />
	<pathelement location="${build.dir}" />
</path>

<target name="buildCards" description="Build package cards">
	<mkdir dir="${build.dir}" />
	<javac includeantruntime="false" destdir="${build.dir}" source="1.7" target="1.7">
		<src path="${srcCards.dir}"/>
	</javac>
</target>

<target name="buildTexas" description="Build package texas" depends="buildCards">
	<javac includeantruntime="false" destdir="${build.dir}" source="1.7" target="1.7">
		<src path="${srcTexasHoldem.dir}"/>
	</javac>
</target>

<target name="buildTest" description="Build test cases" depends="buildTexas">
	<mkdir dir="${build.dir}/test" />
	<javac includeantruntime="false" destdir="${build.dir}/test" source="1.7" target="1.7">
		<classpath refid="junit.class.path" />
		<src path="${srcTest.dir}"/>
	</javac>
</target>
</project>
\end{lstlisting}

I den färdiga versionen så körs även testfallen, och om desa går igenom skapas även en jar-fil för respektive paket.

\begin{lstlisting}[float,caption={build.xml, slutgiltliga versionen (1/2)},label=lst]
<?xml version="1.0"?>
<project name="texas" default="buildJarFiles" basedir=".">
<property name="build.dir" location="bin" />
<property name="cards.src.dir" location="src/cards" />
<property name="texasHoldem.src.dir" location="src/texasholdem" />
<property name="test.src.dir" location="test" />
<property name="test.report.dir" location="testreports" />
<property name="jar.dir" location="jar" />
<property name="eclipse" location="/home/anton/dokument/eclipse" />

<path id="junit.class.path">
	<fileset dir="${eclipse}/plugins" includes="org.junit*/*junit.jar" />
	<fileset dir="${eclipse}/plugins" includes="org.hamcrest*/*junit.jar" />
	<fileset dir="${eclipse}/plugins" includes="org.hamcrest.core*.jar" />
	<pathelement location="${build.dir}" />
</path>

<target name="clean" description="Delete previous jar and class files">
	<delete includeemptydirs="true" dir="jar" />
	<delete includeemptydirs="true" dir="bin" />
</target>

<target name="compileCards" description="Compile package cards" depends="clean">
	<mkdir dir="${build.dir}" />
	<javac includeantruntime="false" destdir="${build.dir}" source="1.7" target="1.7">
		<src path="${cards.src.dir}"/>
	</javac>
</target>

<target name="compileTexas" description="Compile package texasholdem" depends="compileCards">
	<javac includeantruntime="false" destdir="${build.dir}" source="1.7" target="1.7">
		<src path="${texasHoldem.src.dir}"/>
	</javac>
</target>
\end{lstlisting}

\begin{lstlisting}[float,caption={build.xml, slutgiltliga versionen (2/2)},label=lst]
<target name="compileTest" description="Compile test cases" depends="compileTexas, compileCards">
	<javac includeantruntime="false" destdir="${build.dir}" source="1.7" target="1.7">
		<classpath refid="junit.class.path" />
		<src path="${test.src.dir}"/>
	</javac>
</target>

<target name="runTestCases" description="Run test cases" depends="compileTest">
	<junit showoutput="true" printsummary="true" fork="yes" haltonfailure="yes">
		<classpath refid="junit.class.path" />
		<classpath>
			<pathelement location="${build.dir}"/>
		</classpath>
		<formatter type="plain" usefile="false" />
		<batchtest todir="${test.report.dir}">
			<fileset dir="${build.dir}">
				<include name="*Test.class" />
			</fileset>
		</batchtest>
	</junit>
</target>

<target name="buildJarFiles" description="Build .jar-files" depends="compileCards, compileTexas, compileTest, runTestCases">
	<mkdir dir="${jar.dir}" />
	<jar destfile="${jar.dir}/cards.jar" basedir="${build.dir}/cards" includes="*.class" />
	<jar destfile="${jar.dir}/texasholdem.jar" basedir="${build.dir}/texasholdem" includes="*.class" />
</target>

</project>
\end{lstlisting}

